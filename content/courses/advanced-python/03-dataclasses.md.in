---
title: 3. Dataclasses
---

## Motivation

Dataclasses in Python were introduced to simplify the creation of classes that
are primarily used to store data. They address several common pain points in
object-oriented programming:

### Object Equality

#### Value vs Reference Semantics

Traditional Python classes use _reference semantics_[^1] by default:

```python !python classes_reference.py
class Potato():
    def __init__(self):
        self.weight = 100

first = Potato()
second = Potato()

print(first == second)
```


- Traditional classes use reference semantics by default
- Dataclasses make it easy to implement value semantics
- Example: Two dataclass instances with the same attributes are considered
equal

#### Structural Equality
- Dataclasses automatically generate `__eq__` method
- Equality is based on the values of the fields, not object identity
- This behavior aligns with how we intuitively expect data objects to behave

### Boilerplate Reduction
- Eliminates the need to write repetitive `__init__`, `__repr__`, and `__eq__`
methods
- Reduces the chance of errors in these common methods
- Makes code more readable and maintainable

### Copying Objects
- Provides easy ways to create shallow and deep copies of objects
- Useful for creating variations of existing objects without modifying the
original

## Features

- Automatic generation of special methods: `__init__`, `__repr__`, `__eq__`
- Customizable field options: default values, frozen instances, etc.
- Post-init processing with `__post_init__` method
- Integration with type hinting
- Support for inheritance
- Easy conversion to/from dictionaries
- Customizable comparison methods (`__lt__`, `__le__`, etc.)

## Use Cases

1. Data Transfer Objects (DTOs)
2. Configuration objects
3. Immutable data structures (when using `frozen=True`)
4. API responses and requests
5. Representing database records
6. Complex number systems or mathematical objects
7. Game state objects

## When to Avoid Them

1. When you need more control over attribute access (use properties or
descriptors instead)
2. For classes with many methods and little data (traditional classes may be
more appropriate)
3. When you need to maintain backwards compatibility with older Python versions
(< 3.7)
4. If your class requires a complex `__init__` method with extensive logic
5. When working with mutable collections as default values (can lead to
unexpected behavior)
6. If you need to implement a custom `__new__` method
7. For very large classes with hundreds of attributes (may impact performance)

Remember, while dataclasses are powerful, they're not a one-size-fits-all
solution. Always consider your specific use case and requirements when deciding
whether to use a dataclass or a traditional class.

[^1]: In reference semantics:

    - Variables hold references (memory addresses) to objects, not the objects themselves.
    - When you assign an object to a variable, you're creating a new reference to that object, not copying the object.
    - When you pass an object to a function or method, you're passing a reference to the object, not a copy of it.
    - Comparing two variables with == checks if they refer to the same object in memory, not if the objects have the same content.
    - Modifying an object through one reference affects all other references to that object.

    This is in contrast to value semantics, where variables hold the actual data values, and assignments or comparisons involve the data itself, not references to it. Dataclasses in Python provide a way to implement value-like semantics for complex objects, making them behave more intuitively for data storage and comparison purposes.
